// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Maps.TimeZone
{
    /// <summary> The TimeZone service client. </summary>
    public partial class MapsTimeZoneClient
    {
        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        private readonly HttpPipeline _pipeline;

        /// <summary> The restClient is used to access Render REST client. </summary>
        internal TimezoneRestClient restClient { get; }

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of MapsTimeZoneClient. </summary>
        protected MapsTimeZoneClient()
        {
            _clientDiagnostics = null;
            _pipeline = null;
            restClient = null;
        }

        /// <summary> Initializes a new instance of MapsTimeZoneClient. </summary>
        /// <param name="credential"> Shared key credential used to authenticate to an Azure Maps Render Service. </param>
        public MapsTimeZoneClient(AzureKeyCredential credential)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = new Uri("https://atlas.microsoft.com");
            var options = new MapsTimeZoneClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = HttpPipelineBuilder.Build(options, new AzureKeyCredentialPolicy(credential, "subscription-key"));
            restClient = new RenderRestClient(_clientDiagnostics, _pipeline, endpoint, null, options.Version);
        }

        /// <summary> Initializes a new instance of MapsTimeZoneClient. </summary>
        /// <param name="credential"> Shared key credential used to authenticate to an Azure Maps Render Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public MapsTimeZoneClient(AzureKeyCredential credential, MapsTimeZoneClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = options.Endpoint ?? new Uri("https://atlas.microsoft.com");
            options ??= new MapsTimeZoneClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = HttpPipelineBuilder.Build(options, new AzureKeyCredentialPolicy(credential, "subscription-key"));
            restClient = new RenderRestClient(_clientDiagnostics, _pipeline, endpoint, null, options.Version);
        }

        /// <summary> Initializes a new instance of MapsTimeZoneClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Maps Render Service. </param>
        /// <param name="clientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        public MapsTimeZoneClient(TokenCredential credential, string clientId)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = new Uri("https://atlas.microsoft.com");
            var options = new MapsTimeZoneClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            string[] scopes = { "https://atlas.microsoft.com/.default" };
            _pipeline = HttpPipelineBuilder.Build(options, new BearerTokenAuthenticationPolicy(credential, scopes), new AzureKeyCredentialPolicy(new AzureKeyCredential(clientId), "x-ms-client-id"));
            restClient = new RenderRestClient(_clientDiagnostics, _pipeline, endpoint, clientId, options.Version);
        }

        /// <summary> Initializes a new instance of MapsTimeZoneClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Maps Render Service. </param>
        /// <param name="clientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public MapsTimeZoneClient(TokenCredential credential, string clientId, MapsTimeZoneClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = options.Endpoint ?? new Uri("https://atlas.microsoft.com");
            options ??= new MapsTimeZoneClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            string[] scopes = { "https://atlas.microsoft.com/.default" };
            _pipeline = HttpPipelineBuilder.Build(options, new BearerTokenAuthenticationPolicy(credential, scopes), new AzureKeyCredentialPolicy(new AzureKeyCredential(clientId), "x-ms-client-id"));
            restClient = new RenderRestClient(_clientDiagnostics, _pipeline, endpoint, clientId, options.Version);
        }

        /// <summary> Initializes a new instance of MapsTimeZoneClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="clientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/> or <paramref name="pipeline"/> is null. </exception>
        internal MapsTimeZoneClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null, string clientId = null, MapsTimeZoneClientOptions.ServiceVersion apiVersion = MapsTimeZoneClientOptions.LatestVersion)
        {
            var options = new MapsTimeZoneClientOptions(apiVersion);
            restClient = new RenderRestClient(clientDiagnostics, pipeline, endpoint, clientId, options.Version);
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        /// <summary>
        /// __Time Zone by Id__
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns current, historical, and future time zone information for the specified IANA time zone ID.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="timezoneId"> The IANA time zone ID. </param>
        /// <param name="acceptLanguage"> Specifies the language code in which the timezone names should be returned. If no language code is provided, the response will be in &quot;EN&quot;. Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details. </param>
        /// <param name="options"> Alternatively, use alias &quot;o&quot;. Options available for types of information returned in the result. Allowed values: &quot;none&quot; | &quot;zoneInfo&quot; | &quot;transitions&quot; | &quot;all&quot;. </param>
        /// <param name="timeStamp"> Alternatively, use alias &quot;stamp&quot;, or &quot;s&quot;. Reference time, if omitted, the API will use the machine time serving the request. </param>
        /// <param name="daylightSavingsTimeFrom"> Alternatively, use alias &quot;tf&quot;. The start date from which daylight savings time (DST) transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="daylightSavingsTimeLastingYears"> Alternatively, use alias &quot;ty&quot;. The number of years from &quot;transitionsFrom&quot; for which DST transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="timezoneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTimeZoneByIDAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetTimeZoneByIDAsync("<timezoneId>");
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetTimeZoneByIDAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetTimeZoneByIDAsync(<json>, "<timezoneId>", "<acceptLanguage>", "<options>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, 1234);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("Version").ToString());
        /// Console.WriteLine(result.GetProperty("ReferenceUtcTimestamp").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Aliases")[0].ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Name").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Code").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("ISO6391LanguageCode").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Generic").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Standard").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Daylight").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("WallTime").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTzValidYear").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTz").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunrise").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Latitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Longitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcStart").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcEnd").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneResult</c>:
        /// <code>{
        ///   Version: string, # Optional. Version property
        ///   ReferenceUtcTimestamp: string (ISO 8601 Format), # Optional. Reference Utc Timestamp property
        ///   TimeZones: [
        ///     {
        ///       Id: string, # Optional. Id property
        ///       Aliases: [string], # Optional. An array of time zone ID aliases.  Only returned when [options]=*zoneinfo* or *all*.
        ///
        /// Note: may be null.
        ///       Countries: [
        ///         {
        ///           Name: string, # Optional. Country Name
        ///           Code: string, # Optional. ISO-3166 2-letter country code for the country.
        ///         }
        ///       ], # Optional. An array of country records. Only returned when [options]=*zoneinfo* or *all*.
        ///       Names: {
        ///         ISO6391LanguageCode: string, # Optional. The ISO 639-1 language code of the Names
        ///         Generic: string, # Optional. Generic Name
        ///         Standard: string, # Optional. Standard Name
        ///         Daylight: string, # Optional. Daylight Name
        ///       }, # Optional. TimeZone names object.
        ///       ReferenceTime: {
        ///         Tag: string, # Optional. Time zone name in effect at the reference timestamp (i.e. PST or PDT depending whether Daylight Savings Time is in effect).
        ///         StandardOffset: string, # Optional. UTC offset in effect at the `ReferenceUTCTimestamp`.
        ///         DaylightSavings: string, # Optional. Time saving in minutes in effect at the `ReferenceUTCTimestamp`.
        ///         WallTime: string, # Optional. Current wall time at the given time zone as shown in the `Tag` property.
        ///         PosixTzValidYear: number, # Optional. The year this POSIX string is valid for. Note: A POSIX string will only be valid in the given year.
        ///         PosixTz: string, # Optional. POSIX string used to set the time zone environment variable.
        ///         Sunrise: string (ISO 8601 Format), # Optional. Sunrise at the given time zone as shown in the `Tag` property. The sunrise is described in the ISO8601 format. (Only be populated if the call is byCoordinates)
        ///         Sunset: string (ISO 8601 Format), # Optional. Sunset at the given time zone as shown in the `Tag` property. The sunset is described in the ISO8601 format.(Only be populated if the call is byCoordinates)
        ///       }, # Optional. Details in effect at the local time.
        ///       RepresentativePoint: {
        ///         Latitude: number, # Optional. Latitude property
        ///         Longitude: number, # Optional. Longitude property
        ///       }, # Optional. Representative point property
        ///       TimeTransitions: [
        ///         {
        ///           Tag: string, # Optional. Tag property
        ///           StandardOffset: string, # Optional. StandardOffset property
        ///           DaylightSavings: string, # Optional. DaylightSavings property
        ///           UtcStart: string (ISO 8601 Format), # Optional. Start date, start time for this transition period
        ///           UtcEnd: string (ISO 8601 Format), # Optional. End date, end time for this transition period
        ///         }
        ///       ], # Optional. Time zone DST transitions from [transitionsFrom] until timestamp + 1 year.
        ///     }
        ///   ], # Optional. TimeZoneId array
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual async Task<Response> GetTimeZoneByIDAsync(string format = "json", string timezoneId, string acceptLanguage = null, string options = null, DateTimeOffset? timeStamp = null, DateTimeOffset? daylightSavingsTimeFrom = null, int? daylightSavingsTimeLastingYears = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(timezoneId, nameof(timezoneId));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetTimeZoneByID");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTimeZoneByIDRequest(format, timezoneId, acceptLanguage, options, timeStamp, daylightSavingsTimeFrom, daylightSavingsTimeLastingYears, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Time Zone by Id__
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns current, historical, and future time zone information for the specified IANA time zone ID.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="timezoneId"> The IANA time zone ID. </param>
        /// <param name="acceptLanguage"> Specifies the language code in which the timezone names should be returned. If no language code is provided, the response will be in &quot;EN&quot;. Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details. </param>
        /// <param name="options"> Alternatively, use alias &quot;o&quot;. Options available for types of information returned in the result. Allowed values: &quot;none&quot; | &quot;zoneInfo&quot; | &quot;transitions&quot; | &quot;all&quot;. </param>
        /// <param name="timeStamp"> Alternatively, use alias &quot;stamp&quot;, or &quot;s&quot;. Reference time, if omitted, the API will use the machine time serving the request. </param>
        /// <param name="daylightSavingsTimeFrom"> Alternatively, use alias &quot;tf&quot;. The start date from which daylight savings time (DST) transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="daylightSavingsTimeLastingYears"> Alternatively, use alias &quot;ty&quot;. The number of years from &quot;transitionsFrom&quot; for which DST transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="timezoneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTimeZoneByID with required parameters and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetTimeZoneByID("<timezoneId>");
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetTimeZoneByID with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetTimeZoneByID(<json>, "<timezoneId>", "<acceptLanguage>", "<options>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, 1234);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("Version").ToString());
        /// Console.WriteLine(result.GetProperty("ReferenceUtcTimestamp").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Aliases")[0].ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Name").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Code").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("ISO6391LanguageCode").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Generic").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Standard").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Daylight").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("WallTime").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTzValidYear").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTz").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunrise").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Latitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Longitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcStart").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcEnd").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneResult</c>:
        /// <code>{
        ///   Version: string, # Optional. Version property
        ///   ReferenceUtcTimestamp: string (ISO 8601 Format), # Optional. Reference Utc Timestamp property
        ///   TimeZones: [
        ///     {
        ///       Id: string, # Optional. Id property
        ///       Aliases: [string], # Optional. An array of time zone ID aliases.  Only returned when [options]=*zoneinfo* or *all*.
        ///
        /// Note: may be null.
        ///       Countries: [
        ///         {
        ///           Name: string, # Optional. Country Name
        ///           Code: string, # Optional. ISO-3166 2-letter country code for the country.
        ///         }
        ///       ], # Optional. An array of country records. Only returned when [options]=*zoneinfo* or *all*.
        ///       Names: {
        ///         ISO6391LanguageCode: string, # Optional. The ISO 639-1 language code of the Names
        ///         Generic: string, # Optional. Generic Name
        ///         Standard: string, # Optional. Standard Name
        ///         Daylight: string, # Optional. Daylight Name
        ///       }, # Optional. TimeZone names object.
        ///       ReferenceTime: {
        ///         Tag: string, # Optional. Time zone name in effect at the reference timestamp (i.e. PST or PDT depending whether Daylight Savings Time is in effect).
        ///         StandardOffset: string, # Optional. UTC offset in effect at the `ReferenceUTCTimestamp`.
        ///         DaylightSavings: string, # Optional. Time saving in minutes in effect at the `ReferenceUTCTimestamp`.
        ///         WallTime: string, # Optional. Current wall time at the given time zone as shown in the `Tag` property.
        ///         PosixTzValidYear: number, # Optional. The year this POSIX string is valid for. Note: A POSIX string will only be valid in the given year.
        ///         PosixTz: string, # Optional. POSIX string used to set the time zone environment variable.
        ///         Sunrise: string (ISO 8601 Format), # Optional. Sunrise at the given time zone as shown in the `Tag` property. The sunrise is described in the ISO8601 format. (Only be populated if the call is byCoordinates)
        ///         Sunset: string (ISO 8601 Format), # Optional. Sunset at the given time zone as shown in the `Tag` property. The sunset is described in the ISO8601 format.(Only be populated if the call is byCoordinates)
        ///       }, # Optional. Details in effect at the local time.
        ///       RepresentativePoint: {
        ///         Latitude: number, # Optional. Latitude property
        ///         Longitude: number, # Optional. Longitude property
        ///       }, # Optional. Representative point property
        ///       TimeTransitions: [
        ///         {
        ///           Tag: string, # Optional. Tag property
        ///           StandardOffset: string, # Optional. StandardOffset property
        ///           DaylightSavings: string, # Optional. DaylightSavings property
        ///           UtcStart: string (ISO 8601 Format), # Optional. Start date, start time for this transition period
        ///           UtcEnd: string (ISO 8601 Format), # Optional. End date, end time for this transition period
        ///         }
        ///       ], # Optional. Time zone DST transitions from [transitionsFrom] until timestamp + 1 year.
        ///     }
        ///   ], # Optional. TimeZoneId array
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual Response GetTimeZoneByID(string format = "json", string timezoneId, string acceptLanguage = null, string options = null, DateTimeOffset? timeStamp = null, DateTimeOffset? daylightSavingsTimeFrom = null, int? daylightSavingsTimeLastingYears = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(timezoneId, nameof(timezoneId));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetTimeZoneByID");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTimeZoneByIDRequest(format, timezoneId, acceptLanguage, options, timeStamp, daylightSavingsTimeFrom, daylightSavingsTimeLastingYears, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Time Zone by Coordinates__
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns current, historical, and future time zone information for a specified latitude-longitude pair. In addition, the API provides sunset and sunrise times for a given location.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="coordinates"> Coordinates of the point for which time zone information is requested. This parameter is a list of coordinates, containing a pair of coordinate(lat, long). When this endpoint is called directly, coordinates are passed in as a single string containing coordinates, separated by commas. </param>
        /// <param name="acceptLanguage"> Specifies the language code in which the timezone names should be returned. If no language code is provided, the response will be in &quot;EN&quot;. Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details. </param>
        /// <param name="options"> Alternatively, use alias &quot;o&quot;. Options available for types of information returned in the result. Allowed values: &quot;none&quot; | &quot;zoneInfo&quot; | &quot;transitions&quot; | &quot;all&quot;. </param>
        /// <param name="timeStamp"> Alternatively, use alias &quot;stamp&quot;, or &quot;s&quot;. Reference time, if omitted, the API will use the machine time serving the request. </param>
        /// <param name="daylightSavingsTimeFrom"> Alternatively, use alias &quot;tf&quot;. The start date from which daylight savings time (DST) transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="daylightSavingsTimeLastingYears"> Alternatively, use alias &quot;ty&quot;. The number of years from &quot;transitionsFrom&quot; for which DST transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTimeZoneByCoordinatesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetTimeZoneByCoordinatesAsync(new Double[]{1234});
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetTimeZoneByCoordinatesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetTimeZoneByCoordinatesAsync(<json>, new Double[]{1234}, "<acceptLanguage>", "<options>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, 1234);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("Version").ToString());
        /// Console.WriteLine(result.GetProperty("ReferenceUtcTimestamp").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Aliases")[0].ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Name").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Code").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("ISO6391LanguageCode").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Generic").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Standard").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Daylight").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("WallTime").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTzValidYear").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTz").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunrise").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Latitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Longitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcStart").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcEnd").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneResult</c>:
        /// <code>{
        ///   Version: string, # Optional. Version property
        ///   ReferenceUtcTimestamp: string (ISO 8601 Format), # Optional. Reference Utc Timestamp property
        ///   TimeZones: [
        ///     {
        ///       Id: string, # Optional. Id property
        ///       Aliases: [string], # Optional. An array of time zone ID aliases.  Only returned when [options]=*zoneinfo* or *all*.
        ///
        /// Note: may be null.
        ///       Countries: [
        ///         {
        ///           Name: string, # Optional. Country Name
        ///           Code: string, # Optional. ISO-3166 2-letter country code for the country.
        ///         }
        ///       ], # Optional. An array of country records. Only returned when [options]=*zoneinfo* or *all*.
        ///       Names: {
        ///         ISO6391LanguageCode: string, # Optional. The ISO 639-1 language code of the Names
        ///         Generic: string, # Optional. Generic Name
        ///         Standard: string, # Optional. Standard Name
        ///         Daylight: string, # Optional. Daylight Name
        ///       }, # Optional. TimeZone names object.
        ///       ReferenceTime: {
        ///         Tag: string, # Optional. Time zone name in effect at the reference timestamp (i.e. PST or PDT depending whether Daylight Savings Time is in effect).
        ///         StandardOffset: string, # Optional. UTC offset in effect at the `ReferenceUTCTimestamp`.
        ///         DaylightSavings: string, # Optional. Time saving in minutes in effect at the `ReferenceUTCTimestamp`.
        ///         WallTime: string, # Optional. Current wall time at the given time zone as shown in the `Tag` property.
        ///         PosixTzValidYear: number, # Optional. The year this POSIX string is valid for. Note: A POSIX string will only be valid in the given year.
        ///         PosixTz: string, # Optional. POSIX string used to set the time zone environment variable.
        ///         Sunrise: string (ISO 8601 Format), # Optional. Sunrise at the given time zone as shown in the `Tag` property. The sunrise is described in the ISO8601 format. (Only be populated if the call is byCoordinates)
        ///         Sunset: string (ISO 8601 Format), # Optional. Sunset at the given time zone as shown in the `Tag` property. The sunset is described in the ISO8601 format.(Only be populated if the call is byCoordinates)
        ///       }, # Optional. Details in effect at the local time.
        ///       RepresentativePoint: {
        ///         Latitude: number, # Optional. Latitude property
        ///         Longitude: number, # Optional. Longitude property
        ///       }, # Optional. Representative point property
        ///       TimeTransitions: [
        ///         {
        ///           Tag: string, # Optional. Tag property
        ///           StandardOffset: string, # Optional. StandardOffset property
        ///           DaylightSavings: string, # Optional. DaylightSavings property
        ///           UtcStart: string (ISO 8601 Format), # Optional. Start date, start time for this transition period
        ///           UtcEnd: string (ISO 8601 Format), # Optional. End date, end time for this transition period
        ///         }
        ///       ], # Optional. Time zone DST transitions from [transitionsFrom] until timestamp + 1 year.
        ///     }
        ///   ], # Optional. TimeZoneId array
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual async Task<Response> GetTimeZoneByCoordinatesAsync(string format = "json", IEnumerable<double> coordinates, string acceptLanguage = null, string options = null, DateTimeOffset? timeStamp = null, DateTimeOffset? daylightSavingsTimeFrom = null, int? daylightSavingsTimeLastingYears = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetTimeZoneByCoordinates");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTimeZoneByCoordinatesRequest(format, coordinates, acceptLanguage, options, timeStamp, daylightSavingsTimeFrom, daylightSavingsTimeLastingYears, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Time Zone by Coordinates__
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns current, historical, and future time zone information for a specified latitude-longitude pair. In addition, the API provides sunset and sunrise times for a given location.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="coordinates"> Coordinates of the point for which time zone information is requested. This parameter is a list of coordinates, containing a pair of coordinate(lat, long). When this endpoint is called directly, coordinates are passed in as a single string containing coordinates, separated by commas. </param>
        /// <param name="acceptLanguage"> Specifies the language code in which the timezone names should be returned. If no language code is provided, the response will be in &quot;EN&quot;. Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details. </param>
        /// <param name="options"> Alternatively, use alias &quot;o&quot;. Options available for types of information returned in the result. Allowed values: &quot;none&quot; | &quot;zoneInfo&quot; | &quot;transitions&quot; | &quot;all&quot;. </param>
        /// <param name="timeStamp"> Alternatively, use alias &quot;stamp&quot;, or &quot;s&quot;. Reference time, if omitted, the API will use the machine time serving the request. </param>
        /// <param name="daylightSavingsTimeFrom"> Alternatively, use alias &quot;tf&quot;. The start date from which daylight savings time (DST) transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="daylightSavingsTimeLastingYears"> Alternatively, use alias &quot;ty&quot;. The number of years from &quot;transitionsFrom&quot; for which DST transitions are requested, only applies when &quot;options&quot; = all or &quot;options&quot; = transitions. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTimeZoneByCoordinates with required parameters and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetTimeZoneByCoordinates(new Double[]{1234});
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetTimeZoneByCoordinates with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetTimeZoneByCoordinates(<json>, new Double[]{1234}, "<acceptLanguage>", "<options>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, 1234);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("Version").ToString());
        /// Console.WriteLine(result.GetProperty("ReferenceUtcTimestamp").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Aliases")[0].ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Name").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Countries")[0].GetProperty("Code").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("ISO6391LanguageCode").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Generic").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Standard").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("Names").GetProperty("Daylight").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("WallTime").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTzValidYear").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("PosixTz").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunrise").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("ReferenceTime").GetProperty("Sunset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Latitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("RepresentativePoint").GetProperty("Longitude").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("Tag").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("StandardOffset").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("DaylightSavings").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcStart").ToString());
        /// Console.WriteLine(result.GetProperty("TimeZones")[0].GetProperty("TimeTransitions")[0].GetProperty("UtcEnd").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneResult</c>:
        /// <code>{
        ///   Version: string, # Optional. Version property
        ///   ReferenceUtcTimestamp: string (ISO 8601 Format), # Optional. Reference Utc Timestamp property
        ///   TimeZones: [
        ///     {
        ///       Id: string, # Optional. Id property
        ///       Aliases: [string], # Optional. An array of time zone ID aliases.  Only returned when [options]=*zoneinfo* or *all*.
        ///
        /// Note: may be null.
        ///       Countries: [
        ///         {
        ///           Name: string, # Optional. Country Name
        ///           Code: string, # Optional. ISO-3166 2-letter country code for the country.
        ///         }
        ///       ], # Optional. An array of country records. Only returned when [options]=*zoneinfo* or *all*.
        ///       Names: {
        ///         ISO6391LanguageCode: string, # Optional. The ISO 639-1 language code of the Names
        ///         Generic: string, # Optional. Generic Name
        ///         Standard: string, # Optional. Standard Name
        ///         Daylight: string, # Optional. Daylight Name
        ///       }, # Optional. TimeZone names object.
        ///       ReferenceTime: {
        ///         Tag: string, # Optional. Time zone name in effect at the reference timestamp (i.e. PST or PDT depending whether Daylight Savings Time is in effect).
        ///         StandardOffset: string, # Optional. UTC offset in effect at the `ReferenceUTCTimestamp`.
        ///         DaylightSavings: string, # Optional. Time saving in minutes in effect at the `ReferenceUTCTimestamp`.
        ///         WallTime: string, # Optional. Current wall time at the given time zone as shown in the `Tag` property.
        ///         PosixTzValidYear: number, # Optional. The year this POSIX string is valid for. Note: A POSIX string will only be valid in the given year.
        ///         PosixTz: string, # Optional. POSIX string used to set the time zone environment variable.
        ///         Sunrise: string (ISO 8601 Format), # Optional. Sunrise at the given time zone as shown in the `Tag` property. The sunrise is described in the ISO8601 format. (Only be populated if the call is byCoordinates)
        ///         Sunset: string (ISO 8601 Format), # Optional. Sunset at the given time zone as shown in the `Tag` property. The sunset is described in the ISO8601 format.(Only be populated if the call is byCoordinates)
        ///       }, # Optional. Details in effect at the local time.
        ///       RepresentativePoint: {
        ///         Latitude: number, # Optional. Latitude property
        ///         Longitude: number, # Optional. Longitude property
        ///       }, # Optional. Representative point property
        ///       TimeTransitions: [
        ///         {
        ///           Tag: string, # Optional. Tag property
        ///           StandardOffset: string, # Optional. StandardOffset property
        ///           DaylightSavings: string, # Optional. DaylightSavings property
        ///           UtcStart: string (ISO 8601 Format), # Optional. Start date, start time for this transition period
        ///           UtcEnd: string (ISO 8601 Format), # Optional. End date, end time for this transition period
        ///         }
        ///       ], # Optional. Time zone DST transitions from [transitionsFrom] until timestamp + 1 year.
        ///     }
        ///   ], # Optional. TimeZoneId array
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual Response GetTimeZoneByCoordinates(string format = "json", IEnumerable<double> coordinates, string acceptLanguage = null, string options = null, DateTimeOffset? timeStamp = null, DateTimeOffset? daylightSavingsTimeFrom = null, int? daylightSavingsTimeLastingYears = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetTimeZoneByCoordinates");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTimeZoneByCoordinatesRequest(format, coordinates, acceptLanguage, options, timeStamp, daylightSavingsTimeFrom, daylightSavingsTimeLastingYears, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Windows Time Zones__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns a full list of Windows Time Zone IDs.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetWindowsTimeZoneIdsAsync and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetWindowsTimeZoneIdsAsync();
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetWindowsTimeZoneIdsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetWindowsTimeZoneIdsAsync(<json>);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("WindowsId").ToString());
        /// Console.WriteLine(result[0].GetProperty("Territory").ToString());
        /// Console.WriteLine(result[0].GetProperty("IanaIds")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneWindows</c>:
        /// <code>{
        ///   WindowsId: string, # Optional. Windows Id property
        ///   Territory: string, # Optional. Territory property
        ///   IanaIds: [string], # Optional. IanaIds array
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual async Task<Response> GetWindowsTimeZoneIdsAsync(string format = "json", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetWindowsTimeZoneIds");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetWindowsTimeZoneIdsRequest(format, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Windows Time Zones__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns a full list of Windows Time Zone IDs.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetWindowsTimeZoneIds and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetWindowsTimeZoneIds();
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetWindowsTimeZoneIds with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetWindowsTimeZoneIds(<json>);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("WindowsId").ToString());
        /// Console.WriteLine(result[0].GetProperty("Territory").ToString());
        /// Console.WriteLine(result[0].GetProperty("IanaIds")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneWindows</c>:
        /// <code>{
        ///   WindowsId: string, # Optional. Windows Id property
        ///   Territory: string, # Optional. Territory property
        ///   IanaIds: [string], # Optional. IanaIds array
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual Response GetWindowsTimeZoneIds(string format = "json", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetWindowsTimeZoneIds");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetWindowsTimeZoneIdsRequest(format, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __IANA Time Zones__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns a full list of IANA time zone IDs. Updates to the IANA service will be reflected in the system within one day.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetIanaTimeZoneIdsAsync and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetIanaTimeZoneIdsAsync();
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetIanaTimeZoneIdsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetIanaTimeZoneIdsAsync(<json>);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result[0].GetProperty("IsAlias").ToString());
        /// Console.WriteLine(result[0].GetProperty("AliasOf").ToString());
        /// Console.WriteLine(result[0].GetProperty("HasZone1970Location").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>IanaId</c>:
        /// <code>{
        ///   Id: string, # Optional. Id property
        ///   IsAlias: boolean, # Optional. IsAlias property
        ///   AliasOf: string, # Optional. AliasOf property
        ///   HasZone1970Location: boolean, # Optional. This attribute returns `True` if the IanaId has any country/zone associated with it.
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual async Task<Response> GetIanaTimeZoneIdsAsync(string format = "json", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetIanaTimeZoneIds");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetIanaTimeZoneIdsRequest(format, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __IANA Time Zones__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns a full list of IANA time zone IDs. Updates to the IANA service will be reflected in the system within one day.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetIanaTimeZoneIds and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetIanaTimeZoneIds();
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetIanaTimeZoneIds with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetIanaTimeZoneIds(<json>);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result[0].GetProperty("IsAlias").ToString());
        /// Console.WriteLine(result[0].GetProperty("AliasOf").ToString());
        /// Console.WriteLine(result[0].GetProperty("HasZone1970Location").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>IanaId</c>:
        /// <code>{
        ///   Id: string, # Optional. Id property
        ///   IsAlias: boolean, # Optional. IsAlias property
        ///   AliasOf: string, # Optional. AliasOf property
        ///   HasZone1970Location: boolean, # Optional. This attribute returns `True` if the IanaId has any country/zone associated with it.
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual Response GetIanaTimeZoneIds(string format = "json", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetIanaTimeZoneIds");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetIanaTimeZoneIdsRequest(format, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Time Zone IANA Version__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns the current IANA version number as Metadata.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetIanaVersionAsync and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetIanaVersionAsync();
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetIanaVersionAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.GetIanaVersionAsync(<json>);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("Version").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneIanaVersionResult</c>:
        /// <code>{
        ///   Version: string, # Optional. Version property
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual async Task<Response> GetIanaVersionAsync(string format = "json", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetIanaVersion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetIanaVersionRequest(format, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Time Zone IANA Version__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns the current IANA version number as Metadata.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetIanaVersion and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetIanaVersion();
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetIanaVersion with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.GetIanaVersion(<json>);
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("Version").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>TimeZoneIanaVersionResult</c>:
        /// <code>{
        ///   Version: string, # Optional. Version property
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual Response GetIanaVersion(string format = "json", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.GetIanaVersion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetIanaVersionRequest(format, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Windows to IANA Time Zone__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns a corresponding IANA ID, given a valid Windows Time Zone ID. Multiple IANA IDs may be returned for a single Windows ID. It is possible to narrow these results by adding an optional territory parameter.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="windowsTimeZoneId"> The Windows time zone ID. </param>
        /// <param name="windowsTerritoryCode"> Windows Time Zone territory code. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="windowsTimeZoneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ConvertWindowsTimeZoneToIanaAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.ConvertWindowsTimeZoneToIanaAsync("<windowsTimeZoneId>");
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call ConvertWindowsTimeZoneToIanaAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = await client.ConvertWindowsTimeZoneToIanaAsync(<json>, "<windowsTimeZoneId>", "<windowsTerritoryCode>");
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result[0].GetProperty("IsAlias").ToString());
        /// Console.WriteLine(result[0].GetProperty("AliasOf").ToString());
        /// Console.WriteLine(result[0].GetProperty("HasZone1970Location").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>IanaId</c>:
        /// <code>{
        ///   Id: string, # Optional. Id property
        ///   IsAlias: boolean, # Optional. IsAlias property
        ///   AliasOf: string, # Optional. AliasOf property
        ///   HasZone1970Location: boolean, # Optional. This attribute returns `True` if the IanaId has any country/zone associated with it.
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual async Task<Response> ConvertWindowsTimeZoneToIanaAsync(string format = "json", string windowsTimeZoneId, string windowsTerritoryCode = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(windowsTimeZoneId, nameof(windowsTimeZoneId));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.ConvertWindowsTimeZoneToIana");
            scope.Start();
            try
            {
                using HttpMessage message = CreateConvertWindowsTimeZoneToIanaRequest(format, windowsTimeZoneId, windowsTerritoryCode, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// __Windows to IANA Time Zone__
        ///
        ///
        /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
        ///
        ///
        /// This API returns a corresponding IANA ID, given a valid Windows Time Zone ID. Multiple IANA IDs may be returned for a single Windows ID. It is possible to narrow these results by adding an optional territory parameter.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. Allowed values: &quot;json&quot;. </param>
        /// <param name="windowsTimeZoneId"> The Windows time zone ID. </param>
        /// <param name="windowsTerritoryCode"> Windows Time Zone territory code. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="windowsTimeZoneId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ConvertWindowsTimeZoneToIana with required parameters and parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.ConvertWindowsTimeZoneToIana("<windowsTimeZoneId>");
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call ConvertWindowsTimeZoneToIana with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new MapsTimeZoneClient();
        ///
        /// Response response = client.ConvertWindowsTimeZoneToIana(<json>, "<windowsTimeZoneId>", "<windowsTerritoryCode>");
        ///
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("Id").ToString());
        /// Console.WriteLine(result[0].GetProperty("IsAlias").ToString());
        /// Console.WriteLine(result[0].GetProperty("AliasOf").ToString());
        /// Console.WriteLine(result[0].GetProperty("HasZone1970Location").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        ///
        /// Response Body:
        ///
        /// Schema for <c>IanaId</c>:
        /// <code>{
        ///   Id: string, # Optional. Id property
        ///   IsAlias: boolean, # Optional. IsAlias property
        ///   AliasOf: string, # Optional. AliasOf property
        ///   HasZone1970Location: boolean, # Optional. This attribute returns `True` if the IanaId has any country/zone associated with it.
        /// }
        /// </code>
        ///
        /// </remarks>
        public virtual Response ConvertWindowsTimeZoneToIana(string format = "json", string windowsTimeZoneId, string windowsTerritoryCode = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(windowsTimeZoneId, nameof(windowsTimeZoneId));

            using var scope = ClientDiagnostics.CreateScope("MapsTimeZoneClient.ConvertWindowsTimeZoneToIana");
            scope.Start();
            try
            {
                using HttpMessage message = CreateConvertWindowsTimeZoneToIanaRequest(format, windowsTimeZoneId, windowsTerritoryCode, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetTimeZoneByIDRequest(string format, string timezoneId, string acceptLanguage, string options, DateTimeOffset? timeStamp, DateTimeOffset? daylightSavingsTimeFrom, int? daylightSavingsTimeLastingYears, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/timezone/byId/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("query", timezoneId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (options != null)
            {
                uri.AppendQuery("options", options, true);
            }
            if (timeStamp != null)
            {
                uri.AppendQuery("timeStamp", timeStamp.Value, "O", true);
            }
            if (daylightSavingsTimeFrom != null)
            {
                uri.AppendQuery("transitionsFrom", daylightSavingsTimeFrom.Value, "O", true);
            }
            if (daylightSavingsTimeLastingYears != null)
            {
                uri.AppendQuery("transitionsYears", daylightSavingsTimeLastingYears.Value, true);
            }
            request.Uri = uri;
            if (_clientId != null)
            {
                request.Headers.Add("x-ms-client-id", _clientId);
            }
            if (acceptLanguage != null)
            {
                request.Headers.Add("Accept-Language", acceptLanguage);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTimeZoneByCoordinatesRequest(string format, IEnumerable<double> coordinates, string acceptLanguage, string options, DateTimeOffset? timeStamp, DateTimeOffset? daylightSavingsTimeFrom, int? daylightSavingsTimeLastingYears, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/timezone/byCoordinates/", false);
            uri.AppendPath(format, true);
            uri.AppendQueryDelimited("query", coordinates, ",", true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (options != null)
            {
                uri.AppendQuery("options", options, true);
            }
            if (timeStamp != null)
            {
                uri.AppendQuery("timeStamp", timeStamp.Value, "O", true);
            }
            if (daylightSavingsTimeFrom != null)
            {
                uri.AppendQuery("transitionsFrom", daylightSavingsTimeFrom.Value, "O", true);
            }
            if (daylightSavingsTimeLastingYears != null)
            {
                uri.AppendQuery("transitionsYears", daylightSavingsTimeLastingYears.Value, true);
            }
            request.Uri = uri;
            if (_clientId != null)
            {
                request.Headers.Add("x-ms-client-id", _clientId);
            }
            if (acceptLanguage != null)
            {
                request.Headers.Add("Accept-Language", acceptLanguage);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetWindowsTimeZoneIdsRequest(string format, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/timezone/enumWindows/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (_clientId != null)
            {
                request.Headers.Add("x-ms-client-id", _clientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIanaTimeZoneIdsRequest(string format, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/timezone/enumIana/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (_clientId != null)
            {
                request.Headers.Add("x-ms-client-id", _clientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIanaVersionRequest(string format, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/timezone/ianaVersion/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (_clientId != null)
            {
                request.Headers.Add("x-ms-client-id", _clientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateConvertWindowsTimeZoneToIanaRequest(string format, string windowsTimeZoneId, string windowsTerritoryCode, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/timezone/windowsToIana/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("query", windowsTimeZoneId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (windowsTerritoryCode != null)
            {
                uri.AppendQuery("territory", windowsTerritoryCode, true);
            }
            request.Uri = uri;
            if (_clientId != null)
            {
                request.Headers.Add("x-ms-client-id", _clientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
